#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_ARB_shader_draw_parameters : require

out gl_MeshPerVertexEXT
{
    invariant vec4 gl_Position;
} gl_MeshVerticesEXT[];

#define MESHLET_PRIMITIVE_CULL_WAVE32 1
#define MESHLET_RENDER_TASK_HIERARCHICAL 1
#define MESHLET_LOCAL_INVOCATION_INDEXED 0

#extension GL_KHR_shader_subgroup_basic : require
#if defined(MESHLET_PRIMITIVE_CULL_WAVE32) && MESHLET_PRIMITIVE_CULL_WAVE32
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#endif

layout(max_primitives = 32, max_vertices = 32, triangles) out;
layout(local_size_x = 32, local_size_y = 1) in;

#define MESHLET_PAYLOAD_DESCRIPTOR_SET 3
#define MESHLET_PAYLOAD_META_BINDING 1
#define MESHLET_PAYLOAD_STREAM_BINDING 2
#define MESHLET_PAYLOAD_PAYLOAD_BINDING 3
#define MESHLET_VIEWPORT_BINDING 4

#include "inc/meshlet_payload_constants.h"
#include "inc/meshlet_payload_decode.h"
#include "inc/meshlet_attribute_decode.h"
#include "inc/meshlet_render_types.h"
#include "inc/meshlet_primitive_cull.h"
#include "inc/global_bindings.h"
#include "inc/render_parameters.h"
#include "inc/affine.h"

#if !defined(RENDERER_DEPTH)
#define ATTR_LEVEL 2
#elif defined(ALPHA_TEST)
#define ATTR_LEVEL 1
#else
#define ATTR_LEVEL 0
#endif

#if MESHLET_LOCAL_INVOCATION_INDEXED
#define MESHLET_PRIMITIVE_CULL_SHARED_INDEX shared_indices
shared uint shared_indices[32];
shared vec4 shared_clip_pos[32];
#if ATTR_LEVEL >= 1
shared i16vec2 shared_uv[32];
#endif
#if ATTR_LEVEL >= 2
shared u8vec4 shared_nt[32];
shared bool shared_t_sign[32];
shared int shared_exponent[32];
shared vec3 shared_world_pos[32];
#endif
#endif

#if ATTR_LEVEL >= 1
layout(location = 0) out vec2 vUV[];
layout(location = 1) perprimitiveEXT out uint vMaterialID[];
#endif

#if ATTR_LEVEL >= 2
layout(location = 2) out mediump vec3 vNormal[];
layout(location = 3) out mediump vec4 vTangent[];
layout(location = 4) out vec3 vPos[];
#endif

layout(set = MESHLET_PAYLOAD_DESCRIPTOR_SET, binding = MESHLET_VIEWPORT_BINDING) uniform UBOViewport
{
    vec4 viewport;
    float winding;
};

layout(set = 0, binding = BINDING_GLOBAL_SCENE_NODE_TRANSFORMS) readonly buffer AffineTransforms
{
    mat_affine data[];
} transforms;

taskPayloadSharedEXT CompactedDrawInfoPayload mesh_payload;

const uint STRIDE = 4; // TODO: Spec constant or push constant

void main()
{
    uint compacted_meshlet_index = meshlet_get_meshlet_index();

#if !MESHLET_RENDER_TASK_HIERARCHICAL
    CompactedDrawInfo task = mesh_payload.info;
    task.meshlet_index += uint(mesh_payload.offsets[compacted_meshlet_index]);
#else
    CompactedDrawInfo task = mesh_payload.infos[compacted_meshlet_index];
#endif

    mat_affine M = transforms.data[task.node_offset];

    uint linear_index, sublet_index;
    if (gl_SubgroupSize == 32)
    {
        linear_index = gl_SubgroupInvocationID;
        sublet_index = gl_SubgroupID;
    }
    else
    {
        linear_index = gl_LocalInvocationID.x;
        sublet_index = gl_LocalInvocationID.y;
    }

    meshlet_setup_local_invocation(uvec2(linear_index, sublet_index));
    MeshletMetaRuntime meta = meshlet_metas_runtime.data[task.meshlet_index];
    meta.stream_offset += STRIDE * meshlet_get_sublet_index(sublet_index);

    MeshletInfo info = meshlet_get_meshlet_info(meta.stream_offset);
    uvec3 decoded_index_buffer = uvec3(0);
    vec3 world_pos;
    vec4 clip_pos = vec4(-1.0);

    if (linear_index < info.primitive_count)
        decoded_index_buffer = meshlet_decode_index_buffer(meta.stream_offset, linear_index);

    if (linear_index < info.vertex_count)
    {
        int exponent;
        i16vec3 ipos = meshlet_decode_snorm_scaled_i16x3(
            meta.stream_offset + MESHLET_STREAM_TYPE_POSITION,
            linear_index, exponent);
        vec3 pos = ldexp(vec3(ipos), ivec3(exponent));
        world_pos = mul(M, pos);
        clip_pos = global.view_projection * vec4(world_pos, 1.0);
    }

    meshlet_emit_primitive(decoded_index_buffer, clip_pos, viewport, winding);

    if (meshlet_lane_has_active_vert())
    {
        uint out_vert_index = meshlet_compacted_vertex_output();

#if ATTR_LEVEL >= 1
        int exponent;
        i16vec2 uv = meshlet_decode_snorm_scaled_i16x2(
                meta.stream_offset + MESHLET_STREAM_TYPE_UV,
                linear_index, exponent);
#endif

#if ATTR_LEVEL >= 2
        bool t_sign;
        u8vec4 nt = meshlet_decode_normal_tangent_oct8(
                meta.stream_offset + MESHLET_STREAM_TYPE_NORMAL_TANGENT_OCT8,
                linear_index, t_sign);
#endif

#ifdef MESHLET_PRIMITIVE_CULL_SHARED_INDEX
        shared_clip_pos[out_vert_index] = clip_pos;
#if ATTR_LEVEL >= 1
        shared_uv[out_vert_index] = uv;
#endif
#if ATTR_LEVEL >= 2

        shared_nt[out_vert_index] = nt;
        shared_exponent[out_vert_index] = exponent;
        shared_world_pos[out_vert_index] = world_pos;
#endif
#else
        gl_MeshVerticesEXT[out_vert_index].gl_Position = clip_pos;
#if ATTR_LEVEL >= 1
        vUV[out_vert_index] = attribute_decode_snorm_exp_uv(uv, exponent);
#endif
#if ATTR_LEVEL >= 2
        mediump mat2x4 NT = attribute_decode_oct8_normal_tangent(nt, t_sign);
        vNormal[out_vert_index] = mul_normal(M, NT[0].xyz);
        vTangent[out_vert_index] = vec4(mul_normal(M, NT[1].xyz), NT[1].w);
        vPos[out_vert_index] = world_pos;
#endif
#endif
    }

#ifdef MESHLET_PRIMITIVE_CULL_SHARED_INDEX
    barrier();
    if (gl_LocalInvocationIndex < shared_active_vert_count_total)
    {
        gl_MeshVerticesEXT[gl_LocalInvocationIndex].gl_Position = shared_clip_pos[gl_LocalInvocationIndex];

#if ATTR_LEVEL >= 1
        i16vec2 uv = shared_uv[gl_LocalInvocationIndex];
        int exponent = shared_exponent[gl_LocalInvocationIndex];
        vUV[gl_LocalInvocationIndex] = attribute_decode_snorm_exp_uv(uv, exponent);
#endif

#if ATTR_LEVEL >= 2
        u8vec4 nt = shared_nt[gl_LocalInvocationIndex];
        bool t_sign = shared_t_sign[gl_LocalInvocationIndex];
        mediump mat2x4 NT = attribute_decode_oct8_normal_tangent(nt, t_sign);
        vNormal[gl_LocalInvocationIndex] = mul_normal(M, NT[0].xyz);
        vTangent[gl_LocalInvocationIndex] = vec4(mul_normal(M, NT[1].xyz), NT[1].w);
        vPos[gl_LocalInvocationIndex] = shared_world_pos[gl_LocalInvocationIndex];
#endif
    }
#endif

    if (gl_LocalInvocationIndex < shared_active_prim_count_total)
    {
#ifdef MESHLET_PRIMITIVE_CULL_SHARED_INDEX
	    gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationIndex] = uvec3(unpack8(shared_indices[gl_LocalInvocationIndex]).xyz);
#endif

#if ATTR_LEVEL >= 2
        vMaterialID[gl_LocalInvocationIndex] = task.material_offset;
#endif
    }
}
